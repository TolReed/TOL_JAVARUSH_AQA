package com.javarush.task.task15.task1526;

/* 
Дебаг, дебаг, и еще раз дебаг
*/

public class Solution {
    public static void main(String[] args) {
        new B(6);
    }

    public static class A {
        private int f1 = 7;

        public A(int f1) {
            this.f1 = f1;
            initialize();
        }

        private void initialize() { //change protected to private
            System.out.println(f1);
        }
    }

    public static class B extends A {
        protected int f1 = 3;

        public B(int f1) {
            super(f1);
            this.f1 += f1;
            initialize();
        }

        protected void initialize() {
            System.out.println(f1);
        }
    }
}



/*
Порядок инициализации следующий:
1) Статические элементы
2) Глобальные переменные родителя
3) Конструктор родителя
4) Глобальные переменные наследника
5) Конструктор наследника

а) Ситуация до исправления модификатора.
При вызове new B(6) сначала происходит вызов конструктора класса А, а переменная f1 класса В еще не инициализировалась и равна 0.
В конструкторе класса А происходит вызов метода initialize(). Поскольку этот метод может быть переопределен в классах-наследниках,
то компилятор не привязывает вызов этого метода к initialize() класса А, а отдает этот вопрос на решение джава-машины.
Джава-машина видит, что метод вызван из объекта класса В, и соответственно вызывает initialize() класса В.
Однако переменная f1 класса В еще не успела инициализоваться (см. порядок инициализации), поэтому выводится 0.

б) Ситуация после исправления модификатора.
Все то же самое, но теперь компилятор считает, что приватный метод initialize() класса А переопределяться не будет.
Поэтому он жестко привязывает вызов метода initialize() в конструкторе А к initialize() класса А еще ДО выполнения программы.
И джава-машине ничего не остается как вызывать там метод initialize() именно класса А, а не класса В.

В интернете где-то есть по этому поводу информация, что в джаве (в отличие от С++) для приватных и финальных методов применяется раннее связывание (на уровне компилятора),
а для "обычных" методов - позднее связывание (на уровне джава-машины).*/
